name: 合并 Release PR 后自动打 tag、翻标签并清理分支

on:
  pull_request:
    types: [closed]
    branches: [main]

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  tag_and_cleanup:
    # 仅处理已合并且标题包含 "chore(main): release" 的 Release PR
    if: >
      github.event.pull_request.merged == true &&
      contains(github.event.pull_request.title, 'chore(main): release')
    runs-on: ubuntu-latest

    env:
      PR_NUMBER: ${{ github.event.pull_request.number }}
      PR_TITLE: ${{ github.event.pull_request.title }}
      MERGE_SHA: ${{ github.event.pull_request.merge_commit_sha }}
      HEAD_REF: ${{ github.event.pull_request.head.ref }}
      HEAD_REPO: ${{ github.event.pull_request.head.repo.full_name }}
      BASE_REPO: ${{ github.repository }}
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    steps:
      - name: 检出仓库（完整历史）
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: 从 PR 标题解析版本号
        id: parse
        shell: bash
        run: |
          version="$(printf '%s' "$PR_TITLE" | sed -E 's/.*release ([0-9]+\.[0-9]+\.[0-9]+).*/\1/')"
          if [[ -z "$version" ]]; then
            echo "❌ 无法从 PR 标题解析版本号：$PR_TITLE"
            exit 1
          fi
          tag="v$version"
          echo "version=$version" >> "$GITHUB_OUTPUT"
          echo "tag=$tag"         >> "$GITHUB_OUTPUT"
          echo "🧩 解析结果：version=$version, tag=$tag"

      - name: 版本单调性检查（阻止降级）
        shell: bash
        run: |
          want="${{ steps.parse.outputs.tag }}"
          latest="$(git tag --list 'v[0-9]*' --sort=-v:refname | head -n1 || true)"
          echo "🔎 期望打出的 tag: $want"
          if [[ -n "$latest" ]]; then
            w="${want#v}"; l="${latest#v}"
            echo "📌 当前仓库最新 tag: $latest"
            if [ "$(printf '%s\n%s\n' "$l" "$w" | sort -V | head -n1)" != "$l" ]; then
              echo "❌ 解析出的版本 $w 低于现有最新版本 $l，已中止。"
              exit 1
            fi
          else
            echo "ℹ️ 仓库暂无历史 tag，跳过降级检查。"
          fi

      - name: 检查远端是否已存在同名 tag
        id: check
        shell: bash
        run: |
          tag="${{ steps.parse.outputs.tag }}"
          if git ls-remote --tags origin "refs/tags/${tag}" | grep -q "${tag}"; then
            echo "exists=true" >> "$GITHUB_OUTPUT"
            echo "ℹ️ 远端已存在 tag: ${tag}，跳过创建。"
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
            echo "✅ 远端不存在 tag: ${tag}，准备创建。"
          fi

      - name: 创建并推送 tag（如不存在）
        if: steps.check.outputs.exists == 'false'
        shell: bash
        run: |
          tag="${{ steps.parse.outputs.tag }}"
          sha="${MERGE_SHA}"
          if [[ -z "$sha" ]]; then
            echo "❌ 缺少合并提交 SHA，无法打 tag。"
            exit 1
          fi
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git tag -a "$tag" "$sha" -m "Release $tag（via workflow）"
          git push origin "$tag"
          echo "🎉 已推送 tag：$tag -> $sha"

      - name: 翻转 PR 标签（pending → tagged）
        shell: bash
        run: |
          gh pr edit "$PR_NUMBER" --remove-label "autorelease: pending" || true
          gh pr edit "$PR_NUMBER" --add-label    "autorelease: tagged"
          echo "🏷️ 已将 PR #$PR_NUMBER 标签改为：autorelease: tagged"

      - name: 删除 release 分支（仅同仓库分支）
        shell: bash
        run: |
          echo "HEAD_REPO=$HEAD_REPO  BASE_REPO=$BASE_REPO"
          if [[ "$HEAD_REPO" == "$BASE_REPO" ]]; then
            echo "🧹 删除分支：${HEAD_REF}"
            gh api -X DELETE "repos/${BASE_REPO}/git/refs/heads/${HEAD_REF}" || true
          else
            echo "⏭️ 来自 fork 的 PR：${HEAD_REPO}，跳过删除分支。"
          fi
